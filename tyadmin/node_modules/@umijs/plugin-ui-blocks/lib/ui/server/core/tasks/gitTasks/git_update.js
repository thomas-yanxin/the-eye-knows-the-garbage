"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _react() {
  const data = _interopRequireDefault(require("react"));

  _react = function _react() {
    return data;
  };

  return data;
}

function _assert() {
  const data = _interopRequireDefault(require("assert"));

  _assert = function _assert() {
    return data;
  };

  return data;
}

function _umi() {
  const data = require("umi");

  _umi = function _umi() {
    return data;
  };

  return data;
}

function _fs() {
  const data = require("fs");

  _fs = function _fs() {
    return data;
  };

  return data;
}

function _path() {
  const data = require("path");

  _path = function _path() {
    return data;
  };

  return data;
}

function _blockSdk() {
  const data = require("@umijs/block-sdk");

  _blockSdk = function _blockSdk() {
    return data;
  };

  return data;
}

var _helper = require("../helper");

var _this = void 0;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

const winPath = _umi().utils.winPath;

const clone = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator(function* (ctx, args) {
    const logger = ctx.logger,
          execa = ctx.execa;
    const _ref2 = ctx.stages.blockCtx,
          branch = _ref2.branch,
          templateTmpDirPath = _ref2.templateTmpDirPath,
          sourcePath = _ref2.sourcePath,
          routePath = _ref2.routePath;
    logger.appendLog('âš“  Start git fetch');

    try {
      yield execa('git', ['fetch'], {
        cwd: templateTmpDirPath
      });
    } catch (e) {
      logger.appendLog(`Faild git fetch: ${e.message}`);
      throw new Error(e);
    }

    logger.appendLog('ğŸ‰  Success git fetch\n');
    logger.appendLog(`âš“  Start git checkout ${branch}`);

    try {
      yield execa('git', ['checkout', branch], {
        cwd: templateTmpDirPath
      });
    } catch (e) {
      logger.appendLog(`Faild git checkout: ${e.message}\n`);
    }

    logger.appendLog(`ğŸ‰  Success git checkout ${branch}\n`);
    logger.appendLog('âš“  Start git pull');

    try {
      yield execa('git', ['pull'], {
        cwd: templateTmpDirPath
      }); // å¦‚æœæ˜¯ git pull ä¹‹åæœ‰äº†
      // git module åªèƒ½é€šè¿‡è¿™ç§åŠæ³•æ¥åˆå§‹åŒ–ä¸€ä¸‹

      if ((0, _helper.isSubmodule)(templateTmpDirPath)) {
        // ç»“æŸ  git pull çš„ spinner
        // å¦‚æœæ˜¯åˆ†æ”¯åˆ‡æ¢è¿‡æ¥ï¼Œå¯èƒ½æ²¡æœ‰åˆå§‹åŒ–ï¼Œåˆå§‹åŒ–ä¸€ä¸‹
        yield execa('git', ['submodule', 'init'], {
          cwd: templateTmpDirPath,
          env: process.env
        });
        yield execa('git', ['submodule', 'update', '--recursive'], {
          cwd: templateTmpDirPath
        });
      }
    } catch (e) {
      if (e.killed) {
        const err = new Error('Cancel git pull');
        err.name = 'GitUpdateError';
        logger.appendLog('Cancel git pull\n');
        throw err;
      }

      logger.appendLog(`Faild git pull: ${e.message || ''}\n`);
      throw e;
    }

    logger.appendLog('ğŸ‰  Success git pull\n');
    (0, _assert().default)((0, _fs().existsSync)(sourcePath), `${sourcePath} don't exists`);
    let pkg; // get block's package.json

    const pkgPath = (0, _path().join)(sourcePath, 'package.json');

    if (!(0, _fs().existsSync)(pkgPath)) {
      throw new Error(`not find package.json in ${_this.sourcePath}`);
    } else {
      // eslint-disable-next-line
      pkg = JSON.parse((0, _fs().readFileSync)(pkgPath, 'utf-8'));
      ctx.stages.blockCtx.pkg = pkg;
    } // setup route path


    const path = args.path;
    let filePath = '';

    if (!path) {
      const blockName = (0, _blockSdk().getNameFromPkg)(pkg);

      if (!blockName) {
        const errMsg = "Can not find name in block's package.json";
        logger.appendLog(errMsg);
        const err = new Error(errMsg);
        throw err;
      }

      filePath = `/${blockName}`;
    } else {
      filePath = winPath(path);
    }

    ctx.stages.blockCtx.filePath = (0, _helper.addPrefix)(filePath); // å¦‚æœ ctx.routePath ä¸å­˜åœ¨ï¼Œä½¿ç”¨ filePath

    if (!routePath) {
      ctx.stages.blockCtx.routePath = filePath;
    }

    ctx.stages.blockCtx.routePath = (0, _helper.addPrefix)(ctx.stages.blockCtx.routePath);
  });

  return function clone(_x, _x2) {
    return _ref.apply(this, arguments);
  };
}();

var _default = clone;
exports.default = _default;