"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getCtx = getCtx;
exports.addBlock = addBlock;
exports.addPrefix = void 0;

function _react() {
  const data = _interopRequireDefault(require("react"));

  _react = function _react() {
    return data;
  };

  return data;
}

function _assert() {
  const data = _interopRequireDefault(require("assert"));

  _assert = function _assert() {
    return data;
  };

  return data;
}

function _fs() {
  const data = require("fs");

  _fs = function _fs() {
    return data;
  };

  return data;
}

function _path() {
  const data = require("path");

  _path = function _path() {
    return data;
  };

  return data;
}

function _ora() {
  const data = _interopRequireDefault(require("ora"));

  _ora = function _ora() {
    return data;
  };

  return data;
}

function _getnpmregistry() {
  const data = _interopRequireDefault(require("getnpmregistry"));

  _getnpmregistry = function _getnpmregistry() {
    return data;
  };

  return data;
}

function _clipboardy() {
  const data = _interopRequireDefault(require("clipboardy"));

  _clipboardy = function _clipboardy() {
    return data;
  };

  return data;
}

function _utils() {
  const data = require("@umijs/utils");

  _utils = function _utils() {
    return data;
  };

  return data;
}

var _download = require("./download");

var _writeNewRoute = require("./writeNewRoute");

var _getBlockGenerator = require("./getBlockGenerator");

var _appendBlockToContainer = require("./appendBlockToContainer");

var _util = require("./util");

var _installDependencies = require("./installDependencies");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

const merge = _utils().lodash.merge;

const debug = (0, _utils().createDebug)('umiui:block-sdk:addBlock'); // fix demo => /demo

const addPrefix = path => {
  if (!/^\//.test(path)) {
    return `/${path}`;
  }

  return path;
};

exports.addPrefix = addPrefix;

function getCtx(_x) {
  return _getCtx.apply(this, arguments);
}

function _getCtx() {
  _getCtx = _asyncToGenerator(function* (url, args = {}, api) {
    const userConfig = api.userConfig;
    debug(`get url ${url}`);
    const ctx = yield (0, _download.getParsedData)(url, _objectSpread(_objectSpread({}, (userConfig === null || userConfig === void 0 ? void 0 : userConfig.block) || {}), args));

    if (!ctx.isLocal) {
      const blocksTempPath = (0, _download.makeSureMaterialsTempPathExist)(args.dryRun);
      const templateTmpDirPath = (0, _path().join)(blocksTempPath, ctx.id);
      merge(ctx, {
        routePath: args.routePath,
        sourcePath: (0, _path().join)(templateTmpDirPath, ctx.path),
        branch: args.branch || ctx.branch,
        templateTmpDirPath,
        blocksTempPath,
        repoExists: (0, _fs().existsSync)(templateTmpDirPath)
      });
    } else {
      merge(ctx, {
        routePath: args.routePath,
        templateTmpDirPath: (0, _path().dirname)(url)
      });
    }

    return ctx;
  });
  return _getCtx.apply(this, arguments);
}

function addBlock() {
  return _addBlock.apply(this, arguments);
}

function _addBlock() {
  _addBlock = _asyncToGenerator(function* (args = {}, opts = {}, api) {
    const paths = api.paths,
          userConfig = api.userConfig,
          applyPlugins = api.applyPlugins;
    const blockConfig = (userConfig === null || userConfig === void 0 ? void 0 : userConfig.block) || {};
    const spinner = (0, _ora().default)();

    if (!opts.remoteLog) {
      opts.remoteLog = () => {};
    } // 1. parse url and args


    spinner.start('ğŸ˜  Parse url and args');
    const url = args.url;
    (0, _assert().default)(url, `run ${_utils().chalk.cyan.underline('umi help block')} to checkout the usage`);
    const useYarn = (0, _fs().existsSync)((0, _path().join)(paths.cwd, 'yarn.lock'));
    const defaultNpmClient = blockConfig.npmClient || (useYarn ? 'yarn' : 'npm');
    debug(`defaultNpmClient: ${defaultNpmClient}`);
    debug(`args: ${JSON.stringify(args)}`); // get faster registry url

    const registryUrl = yield (0, _getnpmregistry().default)();
    const path = args.path,
          name = args.name,
          routePath = args.routePath,
          index = args.index,
          _args$npmClient = args.npmClient,
          npmClient = _args$npmClient === void 0 ? defaultNpmClient : _args$npmClient,
          dryRun = args.dryRun,
          skipDependencies = args.skipDependencies,
          skipModifyRoutes = args.skipModifyRoutes,
          isPage = args.page,
          isLayout = args.layout,
          _args$registry = args.registry,
          registry = _args$registry === void 0 ? registryUrl : _args$registry,
          js = args.js,
          _args$execution = args.execution,
          execution = _args$execution === void 0 ? 'shell' : _args$execution,
          uni18n = args.uni18n;
    const ctx = yield getCtx(url, args, api);
    spinner.succeed(); // 2. clone git repo

    if (!ctx.isLocal && !ctx.repoExists) {
      opts.remoteLog('Clone the git repo');
      yield (0, _util.gitClone)(ctx, spinner);
    } // 3. update git repo


    if (!ctx.isLocal && ctx.repoExists) {
      try {
        opts.remoteLog('Update the git repo');
        yield (0, _util.gitUpdate)(ctx, spinner);
      } catch (error) {
        _utils().signale.info('å‘ç”Ÿé”™è¯¯ï¼Œè¯·å°è¯• `umi block clear`');
      }
    } // make sure sourcePath exists


    (0, _assert().default)((0, _fs().existsSync)(ctx.sourcePath), `${ctx.sourcePath} don't exists`); // get block's package.json

    const pkgPath = (0, _path().join)(ctx.sourcePath, 'package.json');

    if (!(0, _fs().existsSync)(pkgPath)) {
      throw new Error(`not find package.json in ${this.sourcePath}`);
    } else {
      // eslint-disable-next-line
      ctx.pkg = JSON.parse((0, _fs().readFileSync)(pkgPath, 'utf-8'));
    } // setup route path


    if (!path) {
      const blockName = (0, _getBlockGenerator.getNameFromPkg)(ctx.pkg);

      if (!blockName) {
        _utils().signale.error("not find name in block's package.json");

        return;
      }

      ctx.filePath = `/${blockName}`;

      _utils().signale.info(`Not find --path, use block name '${ctx.filePath}' as the target path.`);
    } else {
      ctx.filePath = (0, _utils().winPath)(path);
    }

    ctx.filePath = addPrefix(ctx.filePath); // å¦‚æœ ctx.routePath ä¸å­˜åœ¨ï¼Œä½¿ç”¨ filePath

    if (!routePath) {
      ctx.routePath = ctx.filePath;
    }

    ctx.routePath = addPrefix(ctx.routePath); // 4. install additional dependencies
    // check dependencies conflict and install dependencies
    // install

    spinner.start('ğŸ“¦  install dependencies package');
    yield (0, _installDependencies.installDependencies)({
      npmClient,
      registry,
      applyPlugins,
      ApplyPluginsType: api.ApplyPluginsType,
      paths,
      debug,
      dryRun,
      spinner,
      skipDependencies
    }, ctx);
    spinner.succeed(); // 5. run generator

    spinner.start('ğŸ”¥  Generate files');

    const _require = require('./getBlockGenerator'),
          getBlockGenerator = _require.getBlockGenerator;

    const BlockGenerator = getBlockGenerator(api);
    let isPageBlock = ctx.pkg.blockConfig && ctx.pkg.blockConfig.specVersion === '0.1';

    if (isPage !== undefined) {
      // when user use `umi block add --page`
      isPageBlock = isPage;
    }

    debug(`isPageBlock: ${isPageBlock}`);
    debug(`ctx.filePath: ${ctx.filePath}`);
    const generator = new BlockGenerator({
      name: args._ ? args._.slice(2) : [],
      args: {
        sourcePath: ctx.sourcePath,
        path: ctx.filePath,
        routePath: ctx.routePath,
        blockName: name || (0, _getBlockGenerator.getNameFromPkg)(ctx.pkg),
        isPageBlock,
        dryRun,
        execution,
        env: {
          cwd: api.cwd
        },
        resolved: (0, _utils().winPath)(__dirname)
      }
    });

    try {
      debug('addBlock - generator start');
      yield generator.run();
      debug('addBlock - generator end');
    } catch (e) {
      spinner.fail();
      throw new Error(e);
    } // write dependencies


    if (ctx.pkg.blockConfig && ctx.pkg.blockConfig.dependencies) {
      const subBlocks = ctx.pkg.blockConfig.dependencies;
      debug('addBlock - write Dependencies');

      try {
        yield Promise.all(subBlocks.map(block => {
          const subBlockPath = (0, _path().join)(ctx.templateTmpDirPath, block);
          debug(`subBlockPath: ${subBlockPath}`);
          return new BlockGenerator({
            name: args._.slice(2),
            args: {
              sourcePath: subBlockPath,
              path: isPageBlock ? generator.path : (0, _path().join)(generator.path, generator.blockFolderName),
              // eslint-disable-next-line
              blockName: (0, _getBlockGenerator.getNameFromPkg)(require((0, _path().join)(subBlockPath, 'package.json'))),
              isPageBlock: false,
              dryRun,
              env: {
                cwd: api.cwd
              },
              routes: api.config.routes,
              resolved: (0, _utils().winPath)(__dirname)
            }
          }).run();
        }));
      } catch (e) {
        spinner.fail();
        throw new Error(e);
      }
    }

    spinner.succeed(); // è°ƒç”¨ sylvanas è½¬åŒ– ts

    if (js) {
      opts.remoteLog('ğŸ¤”  TypeScript to JavaScript');
      spinner.start('ğŸ¤”  TypeScript to JavaScript');

      require('./tsTojs').default(generator.blockFolderPath);

      spinner.succeed();
    }

    if (uni18n) {
      opts.remoteLog('ğŸŒ  remove i18n code');
      spinner.start('ğŸŒ  remove i18n code');

      require('./remove-locale').default(generator.blockFolderPath, uni18n);

      spinner.succeed();
    } // 6. write routes


    if (generator.needCreateNewRoute && api.userConfig.routes && !skipModifyRoutes) {
      var _api$service$configIn;

      opts.remoteLog('â›±  Write route');
      const configFile = (_api$service$configIn = api.service.configInstance) === null || _api$service$configIn === void 0 ? void 0 : _api$service$configIn.configFile;
      spinner.start(`â›±  Write route ${generator.routePath} to ${configFile}`); // å½“å‰ _modifyBlockNewRouteConfig åªæ”¯æŒé…ç½®å¼è·¯ç”±
      // æœªæ¥å¯ä»¥åšä¸‹è‡ªåŠ¨å†™å…¥æ³¨é‡Šé…ç½®ï¼Œæ”¯æŒçº¦å®šå¼è·¯ç”±

      const newRouteConfig = yield applyPlugins({
        key: '_modifyBlockNewRouteConfig',
        type: api.ApplyPluginsType.modify,
        initialValue: _objectSpread({
          path: generator.routePath.toLowerCase(),
          component: `.${generator.path}`
        }, isLayout ? {
          routes: []
        } : {})
      });

      try {
        if (!dryRun) {
          debug('addBlock - writeNewRoute');
          (0, _writeNewRoute.writeNewRoute)(newRouteConfig, configFile, paths.absSrcPath);
        }
      } catch (e) {
        spinner.fail();
        throw new Error(e);
      }

      spinner.succeed();
    } // 6. import block to container


    if (!generator.isPageBlock) {
      spinner.start(`Write block component ${generator.blockFolderName} import to ${generator.entryPath}`);
      debug('addBlock - appendBlockToContainer');

      try {
        (0, _appendBlockToContainer.appendBlockToContainer)({
          entryPath: generator.entryPath,
          blockFolderName: generator.blockFolderName,
          dryRun,
          index
        });
      } catch (e) {
        spinner.fail();
        throw new Error(e);
      }

      spinner.succeed();
    } // Final: show success message


    const _process$env = process.env,
          PORT = _process$env.PORT,
          BASE_PORT = _process$env.BASE_PORT; // Final: show success message

    const viewUrl = `http://localhost:${BASE_PORT || PORT || '8000'}${generator.path.toLowerCase()}`;

    try {
      _clipboardy().default.writeSync(viewUrl);

      _utils().signale.success(`âœ¨  Probable url ${_utils().chalk.cyan(viewUrl)} ${_utils().chalk.dim('(copied to clipboard)')} for view the block.`);
    } catch (e) {
      _utils().signale.success(`âœ¨  Probable url ${_utils().chalk.cyan(viewUrl)} for view the block.`);

      _utils().signale.error('copy to clipboard failed');
    } // return ctx and generator for test


    return {
      generator,
      ctx,
      logs: []
    };
  });
  return _addBlock.apply(this, arguments);
}