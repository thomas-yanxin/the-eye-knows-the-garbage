"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.printBlocks = printBlocks;
exports.gitUpdate = gitUpdate;
exports.gitClone = gitClone;
exports.routeExists = routeExists;
exports.fetchCDNBlocks = fetchCDNBlocks;
exports.fetchBlockList = exports.depthRouterConfig = exports.genComponentToTreeData = exports.genRouterToTreeData = exports.addRoutePrefix = exports.removePrefix = exports.reduceData = exports.getBlockListFromGit = exports.imgFilter = exports.genBlockName = exports.getFastGithub = exports.findJS = void 0;

function _react() {
  const data = _interopRequireDefault(require("react"));

  _react = function _react() {
    return data;
  };

  return data;
}

function _chalk() {
  const data = _interopRequireDefault(require("chalk"));

  _chalk = function _chalk() {
    return data;
  };

  return data;
}

function _path() {
  const data = require("path");

  _path = function _path() {
    return data;
  };

  return data;
}

function _fs() {
  const data = require("fs");

  _fs = function _fs() {
    return data;
  };

  return data;
}

function _utils() {
  const data = require("@umijs/utils");

  _utils = function _utils() {
    return data;
  };

  return data;
}

function _ora() {
  const data = _interopRequireDefault(require("ora"));

  _ora = function _ora() {
    return data;
  };

  return data;
}

function _gitUrlParse() {
  const data = _interopRequireDefault(require("git-url-parse"));

  _gitUrlParse = function _gitUrlParse() {
    return data;
  };

  return data;
}

function _terminalLink() {
  const data = _interopRequireDefault(require("terminal-link"));

  _terminalLink = function _terminalLink() {
    return data;
  };

  return data;
}

var _arrayToTree = _interopRequireDefault(require("./arrayToTree"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

const JS_EXTNAMES = ['.js', '.jsx', '.ts', '.tsx'];

const findJS = opts => {
  const base = opts.base,
        fileNameWithoutExt = opts.fileNameWithoutExt;
  let i = 0;

  while (i < JS_EXTNAMES.length) {
    const extname = JS_EXTNAMES[i];
    const absFilePath = fileNameWithoutExt ? (0, _path().join)(base, `${fileNameWithoutExt}${extname}`) : `${base}${extname}`;

    if ((0, _fs().existsSync)(absFilePath)) {
      return absFilePath;
    }

    i += 1;
  }

  return null;
};
/**
 * å…¨å±€ä½¿ç”¨çš„ loading
 */


exports.findJS = findJS;
const spinner = (0, _ora().default)();
/**
 * åˆ¤æ–­æ˜¯ä¸æ˜¯ä¸€ä¸ª gitmodules çš„ä»“åº“
 */

const isSubmodule = templateTmpDirPath => (0, _fs().existsSync)((0, _path().join)(templateTmpDirPath, '.gitmodules'));
/**
 * Get the fast registry Url(github.com or gitee.com)
 */


const getFastGithub = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator(function* () {
    const registryMap = {
      'github.com': 'https://github.com/ant-design/ant-design.git',
      'gitee.com': 'https://gitee.com/ant-design/pro-blocks'
    };
    const promiseList = Object.keys(registryMap).map( /*#__PURE__*/function () {
      var _ref2 = _asyncToGenerator(function* (key) {
        return (0, _utils().got)(registryMap[key]).catch(() => null).then(() => Promise.resolve(key));
      });

      return function (_x) {
        return _ref2.apply(this, arguments);
      };
    }());

    try {
      const url = yield Promise.race(promiseList);
      return url;
    } catch (e) {
      return 'github.com';
    }
  });

  return function getFastGithub() {
    return _ref.apply(this, arguments);
  };
}();
/**
 * * é¢„è§ˆä¸“ç”¨ *
 * ä»Žæ–‡ä»¶æ•°ç»„æ˜ å°„ä¸º pro çš„è·¯ç”±
 * @param {*} name
 */


exports.getFastGithub = getFastGithub;

const genBlockName = name => name.match(/[A-Z]?[a-z]+|[0-9]+/g).map(p => p.toLowerCase()).join('/');
/**
 * å°†åŒºå—è½¬åŒ–ä¸º inquirer èƒ½ç”¨çš„æ•°ç»„
 * @param {*} blocks
 * @returns {[
 *  name:string;
 *  value:string;
 *  key:string;
 * ]} blockArray
 */


exports.genBlockName = genBlockName;

function printBlocks(blocks, hasLink) {
  const blockArray = [];

  const loopBlocks = (blockItems, parentPath = '') => {
    blockItems.forEach(block => {
      if (block.type === 'block') {
        const blockName = (0, _path().join)(parentPath, block.path);
        const previewUrl = block.previewUrl;
        let name = `ðŸ“¦  ${_chalk().default.cyan(blockName)}  `;

        if (hasLink) {
          // é“¾æŽ¥åˆ° pro çš„é¢„è§ˆç•Œé¢
          // AccountCenter -> account/center
          const link = (0, _terminalLink().default)('é¢„è§ˆ', `https://preview.pro.ant.design/${previewUrl}`); // å¢žåŠ ä¸€ä¸ªé¢„è§ˆçš„ç•Œé¢

          name += link;
        }

        blockArray.push({
          name,
          value: blockName,
          key: blockName
        });
      }

      if (block.type === 'dir') {
        return loopBlocks(block.blocks, block.path);
      }

      return null;
    });
  };

  loopBlocks(blocks);
  return blockArray;
} // https://gitee.com/ant-design/pro-blocks/raw/master/AccountCenter/snapshot.png
// https://raw.githubusercontent.com/ant-design/pro-blocks/master/AccountCenter/snapshot.png?raw=true


const imgFilter = (list, {
  name,
  owner
}, useGitee) => {
  if (!useGitee) {
    return list;
  }

  return list.map(item => _objectSpread(_objectSpread({}, item), {}, {
    img: item.img.replace(`https://raw.githubusercontent.com/${owner}/${name}/master/`, `https://gitee.com/${owner}/${name}/raw/master/`)
  }));
};

exports.imgFilter = imgFilter;

const getBlockListFromGit = /*#__PURE__*/function () {
  var _ref3 = _asyncToGenerator(function* (gitUrl, useBuiltJSON) {
    const ignoreFile = ['_scripts', 'tests'];

    const _GitUrlParse = (0, _gitUrlParse().default)(gitUrl),
          name = _GitUrlParse.name,
          owner = _GitUrlParse.owner,
          resource = _GitUrlParse.resource;

    if (spinner.isSpinning) {
      spinner.succeed();
    }

    if (useBuiltJSON) {
      const fastGithub = yield getFastGithub(); // use blockList.json in git repo

      const url = fastGithub === 'gitee.com' ? `https://gitee.com/${owner}/${name}/raw/master/umi-block.json` : `https://raw.githubusercontent.com/${owner}/${name}/master/umi-block.json`;
      spinner.start(`ðŸ”  find block list form ${_chalk().default.yellow(url)}`);

      try {
        const _yield$got = yield (0, _utils().got)(url),
              body = _yield$got.body;

        spinner.succeed(); // body = {blocks: [], templates: []}

        const data = JSON.parse(body); // TODO update format logic

        return imgFilter(data.list || data.blocks || data.template, {
          name,
          owner
        }, fastGithub === 'gitee.com');
      } catch (error) {// if file 404
      }

      return [];
    } // å¦‚æžœä¸æ˜¯ github ä¸æ”¯æŒè¿™ä¸ªæ–¹æ³•ï¼Œè¿”å›žä¸€ä¸ªç©º
    // å¯ä»¥æžä¸€äº›çº¦å®šï¼Œä¸‹æ¬¡ ä¸‹æ¬¡


    if (resource !== 'github.com') {
      return [];
    } // ä¸€ä¸ª github çš„ api,å¯ä»¥èŽ·å¾—æ–‡ä»¶æ ‘


    const url = `https://api.github.com/repos/${owner}/${name}/git/trees/master`;
    spinner.start(`ðŸ”  find block list form ${_chalk().default.yellow(url)}`);

    const _yield$got2 = yield (0, _utils().got)(url),
          body = _yield$got2.body;

    const filesTree = JSON.parse(body).tree.filter(file => file.type === 'tree' && !ignoreFile.includes(file.path) && file.path.indexOf('.') !== 0).map(({
      path
    }) => ({
      url: `${gitUrl}/tree/master/${path}`,
      type: 'block',
      path,
      isPage: true,
      defaultPath: `/${path}`,
      img: `https://github.com/ant-design/pro-blocks/raw/master/${path}/snapshot.png`,
      tags: ['Ant Design Pro'],
      name: path,
      previewUrl: `https://preview.pro.ant.design/${genBlockName(path)}`
    }));
    spinner.succeed();
    return filesTree;
  });

  return function getBlockListFromGit(_x2, _x3) {
    return _ref3.apply(this, arguments);
  };
}();
/**
 * clone ä¸‹æ¥çš„ git ä¼šç¼“å­˜ã€‚è¿™ä¸ªæ–¹æ³•å¯ä»¥æ›´æ–°ç¼“å­˜
 * @param {*} ctx
 * @param {*} mySpinner
 */


exports.getBlockListFromGit = getBlockListFromGit;

function gitUpdate(_x4, _x5) {
  return _gitUpdate.apply(this, arguments);
}
/**
 * æ‰“å¹³ children
 * {
 *    path:"/user",
 *    children:[{ path: "/user/list" }]
 *  }
 *  --->
 *  /user /user/list
 * @param treeData
 */


function _gitUpdate() {
  _gitUpdate = _asyncToGenerator(function* (ctx, mySpinner) {
    mySpinner.start(`ðŸš›  sync file for git repo --branch ${ctx.branch}`);

    try {
      yield (0, _utils().execa)('git', ['checkout', ctx.branch], {
        cwd: ctx.templateTmpDirPath,
        stdio: 'inherit'
      });
    } catch (e) {
      mySpinner.fail();
      throw new Error(e);
    }

    try {
      yield (0, _utils().execa)('git', ['fetch'], {
        cwd: ctx.templateTmpDirPath,
        stdio: 'inherit'
      });
    } catch (e) {
      mySpinner.fail();
      throw new Error(e);
    }

    try {
      yield (0, _utils().execa)('git', ['pull'], {
        cwd: ctx.templateTmpDirPath,
        stdio: 'inherit'
      }); // å¦‚æžœæ˜¯ git pull ä¹‹åŽæœ‰äº†
      // git module åªèƒ½é€šè¿‡è¿™ç§åŠžæ³•æ¥åˆå§‹åŒ–ä¸€ä¸‹

      if (isSubmodule(ctx.templateTmpDirPath)) {
        // å¦‚æžœæ˜¯åˆ†æ”¯åˆ‡æ¢è¿‡æ¥ï¼Œå¯èƒ½æ²¡æœ‰åˆå§‹åŒ–ï¼Œåˆå§‹åŒ–ä¸€ä¸‹
        yield (0, _utils().execa)('git', ['submodule', 'init'], {
          cwd: ctx.templateTmpDirPath,
          env: process.env,
          stdio: 'inherit'
        });
        yield (0, _utils().execa)('git', ['submodule', 'update', '--recursive'], {
          cwd: ctx.templateTmpDirPath,
          stdio: 'inherit'
        });
      }
    } catch (e) {
      mySpinner.fail();
      throw new Error(e);
    }

    mySpinner.succeed();
  });
  return _gitUpdate.apply(this, arguments);
}

const reduceData = treeData => treeData.reduce((pre, current) => {
  const router = pre[current.key];
  let childrenKeys = {};

  if (current && current.children) {
    childrenKeys = reduceData(current.children);
  }

  if (!router) {
    pre[current.key] = _objectSpread(_objectSpread({}, current), {}, {
      children: undefined
    });
    delete pre[current.key].children;
  }

  return _objectSpread(_objectSpread({}, pre), childrenKeys);
}, {});
/**
 * å…‹éš†åŒºå—çš„åœ°å€
 * @param {*} ctx
 * @param {*} mySpinner
 */


exports.reduceData = reduceData;

function gitClone(_x6, _x7) {
  return _gitClone.apply(this, arguments);
}
/**
 * åˆ é™¤é‡å¤çš„ä¸‹åˆ’çº¿ä»€ä¹ˆçš„
 * @param path
 */


function _gitClone() {
  _gitClone = _asyncToGenerator(function* (ctx, mySpinner) {
    mySpinner.start(`ðŸ”  clone git repo from ${ctx.repo}`);

    try {
      yield (0, _utils().execa)('git', ['clone', ctx.repo, ctx.id, '--recurse-submodules'], {
        cwd: ctx.blocksTempPath,
        env: process.env,
        stdio: 'inherit'
      });
    } catch (e) {
      mySpinner.fail();
      throw new Error(e);
    }

    mySpinner.succeed();
  });
  return _gitClone.apply(this, arguments);
}

const removePrefix = path => path.replace(/\//g, '/').replace(/\/\//g, '/');
/**
 * å¢žåŠ è·¯ç”±å‰ç¼€
 * data -> /data
 * @param path
 * @param parentPath
 */


exports.removePrefix = removePrefix;

const addRoutePrefix = (path = '/', parentPath = '/') => {
  if (path.indexOf('/') !== 0) {
    return removePrefix(`${parentPath}/${path}`);
  }

  return path;
};

exports.addRoutePrefix = addRoutePrefix;

const genRouterToTreeData = (routes, path = '/') => routes.map(item => {
  const prefixPath = addRoutePrefix(item.path, path);

  if (item.path || item.routes) {
    return {
      title: removePrefix(prefixPath.replace(path, '')) || '/',
      value: prefixPath,
      key: prefixPath,
      children: genRouterToTreeData(item.routes || [], prefixPath)
    };
  }

  return undefined;
}).filter(item => item);
/**
 * æ ¹æ® router æ¥èŽ·å–  component
 * ç”¨äºŽåŒºå—çš„æ’å…¥
 * @param {*} routes
 */


exports.genRouterToTreeData = genRouterToTreeData;

const genComponentToTreeData = (routes, path = '/') => routes.map(item => {
  const prefixPath = addRoutePrefix(item.path, path);
  return item.path || item.routes || item.component ? {
    title: removePrefix(prefixPath.replace(path, '/')) || '/',
    value: item.component ? item.component.replace(/(index)?((\.js?)|(\.tsx?)|(\.jsx?))$/, '') : '',
    key: prefixPath,
    children: genComponentToTreeData(item.routes || [], prefixPath)
  } : undefined;
}).filter(item => item);
/**
 * åˆ¤æ–­è·¯ç”±æ˜¯å¦å­˜åœ¨
 * @param {*} path string
 * @param {*} routes
 */


exports.genComponentToTreeData = genComponentToTreeData;

function routeExists(path, routes = []) {
  const routerConfig = reduceData(genRouterToTreeData(routes));

  if (routerConfig[path]) {
    return true;
  }

  return false;
}
/**
 * èŽ·å–è·¯ç”±çš„æ•°æ®
 * @param {*} routes
 */


const depthRouterConfig = routerConfig => {
  const getParentKey = (key = '') => {
    const routerKeyArray = key.split('/').filter(routerKey => routerKey);
    routerKeyArray.pop();
    return `/${routerKeyArray.join('/')}`;
  };

  return (0, _arrayToTree.default)(Object.keys(routerConfig).sort((a, b) => a.split('/').length - b.split('/').length + a.length - b.length).map(key => {
    const parentKey = getParentKey(key);
    return _objectSpread(_objectSpread({}, routerConfig[key]), {}, {
      parentKey: parentKey === '/' ? null : parentKey
    });
  }), {
    id: 'key',
    parentId: 'parentKey',
    dataField: null
  });
};
/**
 * get BlockList from blockList.json in github repo
 */


exports.depthRouterConfig = depthRouterConfig;

const fetchBlockList = /*#__PURE__*/function () {
  var _ref4 = _asyncToGenerator(function* (repo) {
    try {
      const blocks = yield getBlockListFromGit(`https://github.com/${repo}`, true);
      return {
        data: blocks,
        success: true
      };
    } catch (error) {
      return {
        message: error.message,
        data: undefined,
        success: false
      };
    }
  });

  return function fetchBlockList(_x8) {
    return _ref4.apply(this, arguments);
  };
}();
/**
 * é€šè¿‡ npm CDN url èŽ·å–åŒºå—æ•°æ®
 * @param pkg åŒ…å
 */


exports.fetchBlockList = fetchBlockList;

function fetchCDNBlocks(_x9) {
  return _fetchCDNBlocks.apply(this, arguments);
}

function _fetchCDNBlocks() {
  _fetchCDNBlocks = _asyncToGenerator(function* ({
    pkg,
    summary = 'umi-block.json',
    version = 'latest',
    factor
  }) {
    const prefixCDN = `https://cdn.jsdelivr.net/npm/${pkg}@${version}`;

    try {
      const _yield$got3 = yield (0, _utils().got)(`${prefixCDN}/${summary}`),
            body = _yield$got3.body;

      const data = JSON.parse(body);
      const list = (data.list || data.blocks || data.template).map(factor || (item => item));
      return {
        data: list,
        success: true
      };
    } catch (error) {
      return {
        message: error.message,
        data: undefined,
        success: false
      };
    }
  });
  return _fetchCDNBlocks.apply(this, arguments);
}