"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _react() {
  const data = _interopRequireDefault(require("react"));

  _react = function _react() {
    return data;
  };

  return data;
}

function _fs() {
  const data = require("fs");

  _fs = function _fs() {
    return data;
  };

  return data;
}

function _crypto() {
  const data = require("crypto");

  _crypto = function _crypto() {
    return data;
  };

  return data;
}

function _umi() {
  const data = require("umi");

  _umi = function _umi() {
    return data;
  };

  return data;
}

function _path() {
  const data = require("path");

  _path = function _path() {
    return data;
  };

  return data;
}

function _os() {
  const data = require("os");

  _os = function _os() {
    return data;
  };

  return data;
}

function _mkdirp() {
  const data = _interopRequireDefault(require("mkdirp"));

  _mkdirp = function _mkdirp() {
    return data;
  };

  return data;
}

function _assert() {
  const data = _interopRequireDefault(require("assert"));

  _assert = function _assert() {
    return data;
  };

  return data;
}

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const _utils$lodash = _umi().utils.lodash,
      get = _utils$lodash.get,
      pickBy = _utils$lodash.pickBy,
      identity = _utils$lodash.identity;

class Config {
  constructor(opts = {}) {
    this.dbPath = void 0;
    this.data = void 0;
    this.onSave = void 0;
    const dbPath = opts.dbPath,
          onSave = opts.onSave;
    this.dbPath = dbPath || (0, _path().join)((0, _os().homedir)(), `.umi3/ui/${process.env.BIGFISH_COMPAT ? 'bigfish-data' : 'data'}.json`);
    this.onSave = onSave;

    _mkdirp().default.sync((0, _path().dirname)(this.dbPath));

    this.load();
  }

  load() {
    if ((0, _fs().existsSync)(this.dbPath)) {
      try {
        this.data = JSON.parse((0, _fs().readFileSync)(this.dbPath, 'utf-8'));
      } catch (e) {
        this.data = {};
      }
    } else {
      this.data = {};
    }

    if (!this.data.projectsByKey) {
      this.data.projectsByKey = {};
    }
  }

  save() {
    (0, _fs().writeFileSync)(this.dbPath, JSON.stringify(this.data, null, 2), 'utf-8');
    if (this.onSave) this.onSave(this.data);
  }

  addProject({
    name,
    path,
    npmClient,
    createOpts,
    ignoreExistsCheck
  }) {
    name = (0, _path().basename)(name || path);
    const str = `${path}____${name}`;
    const key = (0, _crypto().createHash)('md5').update(str).digest('hex').slice(0, 6);

    if (!ignoreExistsCheck) {
      (0, _assert().default)(!this.data.projectsByKey[key], `Key of path ${path} exists, please try another one.`);
    }

    this.data.projectsByKey[key] = {
      path,
      name,
      created_at: +new Date(),
      npmClient,
      createOpts
    };
    this.save();
    return key;
  }

  deleteProject(key) {
    delete this.data.projectsByKey[key];

    if (this.data.currentProject === key) {
      delete this.data.currentProject;
    }

    this.save();
  }

  editProject(key, newProps) {
    this.data.projectsByKey[key] = _objectSpread(_objectSpread({}, this.data.projectsByKey[key]), pickBy(newProps, identity));
    this.save();
  }

  setCreatingProgress(key, args) {
    // KEY
    // step: 1,
    // stepStatus: 'loading',
    // steps: [''],
    this.data.projectsByKey[key].creatingProgress = _objectSpread(_objectSpread({}, this.data.projectsByKey[key].creatingProgress), args);
    this.save();
  }

  setCreatingProgressDone(key) {
    delete this.data.projectsByKey[key].creatingProgress;
    this.save();
  }

  setCurrentProject(key) {
    (0, _assert().default)(this.data.projectsByKey[key], `project of key ${key} not found`);
    (0, _assert().default)(get(this.data, `projectsByKey.${key}.creatingProgress.success`) || !get(this.data, `projectsByKey.${key}.creatingProgress`), `project of key ${key} is still creating`);
    this.data.currentProject = key;
    this.save();
  }

  clearCurrentProject() {
    this.data.currentProject = null;
    this.save();
  }

  setProjectNpmClient({
    npmClient,
    key
  }) {
    this.data.projectsByKey[key].npmClient = npmClient;
    this.save();
  }

  addProjectWithPath(projectPath) {
    const absProjectPath = (0, _path().join)(projectPath);
    const pathArray = absProjectPath.split('/');
    const projectName = pathArray[pathArray.length - 1];
    return this.addProject({
      name: projectName,
      path: absProjectPath,
      ignoreExistsCheck: true
    });
  }

  getKeyOrAddWithPath(projectPath) {
    const keys = Object.keys(this.data.projectsByKey);

    for (var _i = 0, _keys = keys; _i < _keys.length; _i++) {
      const key = _keys[_i];

      if (this.data.projectsByKey[key].path === projectPath) {
        return key;
      }
    }

    return this.addProjectWithPath(projectPath);
  }

  checkValid() {
    for (var _i2 = 0, _Object$keys = Object.keys(this.data.projectsByKey); _i2 < _Object$keys.length; _i2++) {
      const key = _Object$keys[_i2];
      const path = this.data.projectsByKey[key].path; // 删除不存在的项目

      if (!(0, _fs().existsSync)(path)) {
        delete this.data.projectsByKey[key];

        if (this.data.currentProject === key) {
          this.data.currentProject = null;
        }
      }
    }
  }

}

exports.default = Config;