import './index.less';
import React, { CSSProperties, ReactNode } from 'react';
import { TableProps, ColumnType } from 'antd/es/table';
import { ColumnFilterItem } from 'antd/es/table/interface';
import { FormItemProps, FormProps, FormInstance } from 'antd/es/form';
import { IntlType } from './component/intlContext';
import { UseFetchDataAction, RequestData } from './useFetchData';
import { OptionConfig, ToolBarProps } from './component/toolBar';
import { SearchConfig, TableFormItem } from './form';
import { StatusType } from './component/status';
import { ProColumnsValueType, ProColumnsValueTypeFunction } from './defaultRender';
import { DensitySize } from './component/toolBar/DensityIcon';
export interface ActionType {
    reload: (resetPageIndex?: boolean) => void;
    reloadAndRest: () => void;
    fetchMore: () => void;
    reset: () => void;
    clearSelected: () => void;
}
export interface ColumnsState {
    show?: boolean;
    fixed?: 'right' | 'left' | undefined;
}
export declare type ValueEnumObj = {
    [key: string]: {
        text: ReactNode;
        status: StatusType;
    } | ReactNode;
};
export declare type ValueEnumMap = Map<React.ReactText, {
    text: ReactNode;
    status: StatusType;
} | ReactNode>;
export interface ProColumnType<T = unknown> extends Omit<ColumnType<T>, 'render' | 'children' | 'title' | 'filters'>, Partial<Omit<FormItemProps, 'children'>> {
    index?: number;
    title?: ReactNode | ((config: ProColumnType<T>, type: ProTableTypes) => ReactNode);
    /**
     * è‡ªå®šä¹‰ render
     */
    render?: (text: React.ReactNode, record: T, index: number, action: UseFetchDataAction<RequestData<T>>) => React.ReactNode | React.ReactNode[];
    /**
     * è‡ªå®šä¹‰ renderï¼Œä½†æ˜¯éœ€è¦è¿”å› string
     */
    renderText?: (text: any, record: T, index: number, action: UseFetchDataAction<RequestData<T>>) => any;
    /**
     * è‡ªå®šä¹‰æœç´¢ form çš„è¾“å…¥
     */
    renderFormItem?: (item: ProColumns<T>, config: {
        value?: any;
        onChange?: (value: any) => void;
        onSelect?: (value: any) => void;
        type: ProTableTypes;
        defaultRender: (newItem: ProColumns<any>) => JSX.Element | null;
    }, form: FormInstance) => JSX.Element | false | null;
    /**
     * æœç´¢è¡¨å•çš„ props
     */
    formItemProps?: {
        [prop: string]: any;
    };
    /**
     * æœç´¢è¡¨å•çš„é»˜è®¤å€¼
     */
    initialValue?: any;
    /**
     * æ˜¯å¦ç¼©ç•¥
     */
    ellipsis?: boolean;
    /**
     * æ˜¯å¦æ‹·è´
     */
    copyable?: boolean;
    /**
     * å€¼çš„ç±»å‹
     */
    valueType?: ProColumnsValueType | ProColumnsValueTypeFunction<T>;
    /**
     * å€¼çš„æšä¸¾ï¼Œå¦‚æœå­˜åœ¨æšä¸¾ï¼ŒSearch ä¸­ä¼šç”Ÿæˆ select
     */
    valueEnum?: ValueEnumMap | ValueEnumObj;
    /**
     * åœ¨æŸ¥è¯¢è¡¨å•ä¸­éšè—
     */
    hideInSearch?: boolean;
    /**
     * åœ¨ table ä¸­éšè—
     */
    hideInTable?: boolean;
    /**
     * åœ¨æ–°å»ºè¡¨å•ä¸­åˆ é™¤
     */
    hideInForm?: boolean;
    /**
     * è¡¨å¤´çš„ç­›é€‰èœå•é¡¹
     */
    filters?: boolean | ColumnFilterItem[];
    /**
     * form çš„æ’åº
     */
    order?: number;
    customCol?: any;
}
export interface ProColumnGroupType<RecordType> extends ProColumnType<RecordType> {
    children: ProColumns<RecordType>;
}
export declare type ProColumns<T = {}> = ProColumnGroupType<T> | ProColumnType<T>;
export declare type ProTableTypes = 'form' | 'list' | 'table' | 'cardList' | undefined;
export interface ProTableProps<T, U extends {
    [key: string]: any;
}> extends Omit<TableProps<T>, 'columns' | 'rowSelection'> {
    columns?: ProColumns<T>[];
    params?: U;
    columnsStateMap?: {
        [key: string]: ColumnsState;
    };
    onColumnsStateChange?: (map: {
        [key: string]: ColumnsState;
    }) => void;
    onSizeChange?: (size: DensitySize) => void;
    /**
     * æ¸²æŸ“ table
     */
    tableRender?: (props: ProTableProps<T, U>, defaultDom: JSX.Element, 
    /**
     * å„ä¸ªåŒºåŸŸçš„ dom
     */
    domList: {
        toolbar: JSX.Element | undefined;
        alert: JSX.Element | undefined;
        table: JSX.Element | undefined;
    }) => React.ReactNode;
    tableExtraRender?: (props: ProTableProps<T, U>, dataSource: T[]) => React.ReactNode;
    /**
     * ä¸€ä¸ªè·å¾— dataSource çš„æ–¹æ³•
     */
    request?: (params: U & {
        pageSize?: number;
        current?: number;
    }, sort: {
        [key: string]: 'ascend' | 'descend';
    }, filter: {
        [key: string]: React.ReactText[];
    }) => Promise<RequestData<T>>;
    /**
     * å¯¹æ•°æ®è¿›è¡Œä¸€äº›å¤„ç†
     */
    postData?: (data: any[]) => any[];
    /**
     * é»˜è®¤çš„æ•°æ®
     */
    defaultData?: T[];
    /**
     * åˆå§‹åŒ–çš„å‚æ•°ï¼Œå¯ä»¥æ“ä½œ table
     */
    actionRef?: React.MutableRefObject<ActionType | undefined> | ((actionRef: ActionType) => void);
    /**
     * æ“ä½œè‡ªå¸¦çš„ form
     */
    formRef?: TableFormItem<T>['formRef'];
    /**
     * æ¸²æŸ“æ“ä½œæ 
     */
    toolBarRender?: ToolBarProps<T>['toolBarRender'] | false;
    /**
     * æ•°æ®åŠ è½½å®Œæˆåè§¦å‘
     */
    onLoad?: (dataSource: T[]) => void;
    /**
     * æ•°æ®åŠ è½½å¤±è´¥æ—¶è§¦å‘
     */
    onRequestError?: (e: Error) => void;
    /**
     * ç»™å°è£…çš„ table çš„ className
     */
    tableClassName?: string;
    /**
     * ç»™å°è£…çš„ table çš„ style
     */
    tableStyle?: CSSProperties;
    /**
     * å·¦ä¸Šè§’çš„ title
     */
    headerTitle?: React.ReactNode;
    /**
     * é»˜è®¤çš„æ“ä½œæ é…ç½®
     */
    options?: OptionConfig<T> | false;
    /**
     * æ˜¯å¦æ˜¾ç¤ºæœç´¢è¡¨å•
     */
    search?: boolean | SearchConfig;
    /**
     * type="form" å’Œ æœç´¢è¡¨å• çš„ Form é…ç½®
     * åŸºæœ¬é…ç½®ä¸ antd Form ç›¸åŒ
     *  ä½†æ˜¯åŠ«æŒäº† form çš„é…ç½®
     */
    form?: Omit<FormProps, 'form'>;
    /**
     * å¦‚ä½•æ ¼å¼åŒ–æ—¥æœŸ
     * æš‚æ—¶åªæ”¯æŒ moment
     * string ä¼šæ ¼å¼åŒ–ä¸º YYYY-DD-MM
     * number ä»£è¡¨æ—¶é—´æˆ³
     */
    dateFormatter?: 'string' | 'number' | false;
    /**
     * æ ¼å¼åŒ–æœç´¢è¡¨å•æäº¤æ•°æ®
     */
    beforeSearchSubmit?: (params: Partial<T>) => Partial<T>;
    /**
     * è‡ªå®šä¹‰ table çš„ alert
     * è®¾ç½®æˆ–è€…è¿”å›false å³å¯å…³é—­
     */
    tableAlertRender?: ((props: {
        intl: IntlType;
        selectedRowKeys: (string | number)[];
        selectedRows: T[];
    }) => React.ReactNode) | false;
    /**
     * è‡ªå®šä¹‰ table çš„ alert çš„æ“ä½œ
     * è®¾ç½®æˆ–è€…è¿”å›false å³å¯å…³é—­
     */
    tableAlertOptionRender?: ((props: {
        intl: IntlType;
        onCleanSelected: () => void;
    }) => React.ReactNode) | false;
    rowSelection?: TableProps<T>['rowSelection'] | false;
    style?: React.CSSProperties;
    /**
     * æ”¯æŒ ProTable çš„ç±»å‹
     */
    type?: ProTableTypes;
    /**
     * æäº¤è¡¨å•æ—¶è§¦å‘
     */
    onSubmit?: (params: U) => void;
    /**
     * é‡ç½®è¡¨å•æ—¶è§¦å‘
     */
    onReset?: () => void;
    /**
     * ç©ºå€¼æ—¶æ˜¾ç¤º
     */
    columnEmptyText?: ColumnEmptyText;
}
export declare type ColumnEmptyText = string | false;
/**
 * ğŸ† Use Ant Design Table like a Pro!
 * æ›´å¿« æ›´å¥½ æ›´æ–¹ä¾¿
 * @param props
 */
declare const ProviderWarp: <T, U extends {
    [key: string]: any;
} = {}>(props: ProTableProps<T, U>) => JSX.Element;
export default ProviderWarp;
